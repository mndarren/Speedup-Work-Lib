#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
.. current_module:: publish_pypi.py
.. created_by:: Darren Xie
.. created_on:: 05/06/2021

Publish this speedup-work-lib to pypi.
"""
import os
import re
import stat
import subprocess
import sys
from codecs import open
from datetime import datetime
from pathlib import Path
from shutil import rmtree
from subprocess import call, PIPE, Popen

TIME_FORMAT = '%m/%d/%Y %H:%M:%S'


class PublishPypi:
    """
    This class is to publish library to pypi. PLEASE put the .pypirc file in home directory first.
    1. Clean up the directories and files generated by publish or other commands;
    2. Generate the package;
    3. Test package;
    4. Publish package to Pypi.
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.orig_content_ver = ''
        self.version_file = Path(__file__).parent.joinpath('speedup_work_lib/__init__.py')

    def run(self):
        """This is the main function."""
        self._print_log(f"Start publishing.")
        self.cleanup()

        self.publish_pypi()

        self.cleanup()
        self._print_log(f"Done to publish speedup-work-lib.")

    def _print_log(self, msg=''):
        """print out the log message"""
        sys.stdout.write(f"[{datetime.now().strftime(TIME_FORMAT)}]: {msg}\n")

    def cleanup(self):
        """Clean up all useless directories and files"""
        self._print_log("Start Cleaning up.")
        directories_list = [
            '.pytest_cache',
            'build',
            'dist',
            'speedup_work_lib.egg-info',
        ]
        files = [
            '.coverage'
        ]
        curr_path = Path(__file__).parent
        for dir_ in directories_list:
            if curr_path.joinpath(dir_).exists():
                rmtree(curr_path.joinpath(dir_), onerror=self.on_rm_error)
        for f in files:
            if curr_path.joinpath(f).exists():
                os.unlink(curr_path.joinpath(f))

    def on_rm_error(self, func, path, exc_info):
        """
        This function is for shutil.rmtree() onerror=self.on_rm_error
        :param func:
        :param path:
        :param exc_info:
        :return:
        """
        # path contains the path of the file that couldn't be removed
        # let's just assume that it's read-only and unlink it.
        os.chmod(path, stat.S_IWRITE)
        os.unlink(path)

    def publish_pypi(self):
        """Publish lib to pypi"""
        self._print_log(f"Start building package")
        # Build package
        self.increment_version()
        build_package_cmds = [
            # 'pip freeze > requirements.txt',
            'python setup.py sdist bdist_wheel',
        ]
        try:
            for cmd in build_package_cmds:
                call(cmd, shell=True)
        except:
            self.decrement_version()

        # Check package
        self._print_log(f"Start Checking package.")
        check_cmd = 'twine check dist/*'
        p = Popen(check_cmd, stdin=PIPE, stdout=PIPE, shell=True)
        count = p.stdout.read().decode().count('PASSED')
        p.terminate()

        # Publish package
        self._print_log(f"Start publishing package.")
        if count == 2:
            publish_cmds = [
                'twine upload -r pypitest dist/*',
                'twine upload -r pypi dist/*',
            ]
            try:
                for cmd in publish_cmds:
                    self._print_log(f"Start running {cmd}")
                    subprocess.call(cmd)
            except:
                self.decrement_version()
        else:
            self._print_log(f"Failed to check dist/ packages.")

    def increment_version(self):
        """Increment version number
        Rule: update the build number +1;
        if build number == 10, the minor number +1;
        if minor number == 10, the major number +1.
        """
        VERSION_RE = re.compile(r'.*(\d+\.\d+\.\d+).*')
        with open(str(self.version_file), 'r') as in_fh,\
                open(f"{str(self.version_file)}_r", 'w') as out_fh:
            content = in_fh.read()
            self.orig_content_ver = content
            orig_v_num = re.search(VERSION_RE, content).group(1)
            v_num = orig_v_num.split('.')
            new_build_num = int(v_num[2]) + 1
            if new_build_num < 10:
                v_num[2] = str(new_build_num)
            else:  # new build number == 10
                new_minor_num = int(v_num[1]) + 1
                if new_minor_num < 10:
                    v_num[1] = str(new_minor_num)
                else:  # new minor number == 10
                    v_num[0] = str(int(v_num[0]) + 1)

            new_v_num = '.'.join(v_num)
            new_content = content.replace(orig_v_num, new_v_num)

            out_fh.write(new_content)

        os.unlink(self.version_file)
        os.rename(f"{str(self.version_file)}_r", self.version_file)

    def decrement_version(self):
        """
        Decrement version. Go back to the original version.
        """
        with open(f"{str(self.version_file)}_r", 'w') as out_fh:
            out_fh.write(self.orig_content_ver)

        os.unlink(self.version_file)
        os.rename(f"{str(self.version_file)}_r", self.version_file)


if __name__ == "__main__":
    PublishPypi().run()
